<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gra</title>
    <style>
        /* Stylizacja szachownicy */
        .board {
            display: grid;
            grid-template-columns: repeat(8, 50px); /* Odpowiada szerokości komórki planszy w pikselach */
            grid-template-rows: repeat(8, 50px); /* Odpowiada wysokości komórki planszy w pikselach */
        }

        .cell {
            width: 50px; /* Szerokość komórki planszy w pikselach */
            height: 50px; /* Wysokość komórki planszy w pikselach */
            border: 1px solid black;
            position: relative; /* Dodaj pozycję względną, aby pionki były pozycjonowane wewnątrz komórki */
        }

        .white {
            background-color: white;
        }

        .black {
            background-color: #d3d3d3; /* Kolor dla czarnych pól */
        }

        .sheep {
            position: absolute;
            width: 40px; /* Szerokość pionka owcy */
            height: 40px; /* Wysokość pionka owcy */
            background-color: #a3c8eb;
            border-radius: 50%;
            /* Ustaw pozycję pionka w środku komórki */
            left: 5px; /* Odstęp od lewej krawędzi komórki */
            top: 5px; /* Odstęp od górnej krawędzi komórki */
            z-index: 1;
        }

        .wolf {
            position: absolute;
            width: 40px; /* Szerokość pionka wilka */
            height: 40px; /* Wysokość pionka wilka */
            background-color: gray;
            border-radius: 50%;
            left: 5px; /* Odstęp od lewej krawędzi komórki */
            top: 5px; /* Odstęp od górnej krawędzi komórki */
            z-index: 1; /* Ustawienie pionka wilka na pierwszym planie */
        }

        .piece {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;

        }
    </style>

    <script>
        // Store initial positions of sheeps
        const initialSheepPositions = {{ sheep_positions | tojson | safe }};

    </script>

</head>
<body>
    {% set initial_wolf_row = 0 %}
    {% set initial_wolf_col = 0 %}
    {% set wolf_position = [initial_wolf_row, initial_wolf_col] %}

    {% block content %}

    <p>{{ result }}</p>
    <p>{{ computer_result }}</p>


    <h1>Grajmy!</h1>

        {% if not is_game_over %}
          <p>Gra trwa.</p>
        {% endif %}


    <div class="board">
        {% for row in range(8) %}
            {% for col in range(8) %}
                <div class="cell {% if (row + col) % 2 == 0 %}white{% else %}black{% endif %}">
                    {% if row == wolf_position[0] and col == wolf_position[1] %}
                        <!-- Pionek wilka -->
                        <div class="piece wolf" id="wolf" style="cursor: pointer;" data-initial-position="{{ wolf.get_position() }}" data-current-row="{{ wolf_position[0] }}" data-current-col="{{ wolf_position[1] }}"
                        onstop="handlePieceStop(event, ui, 'wolf')">
                        </div>
                    {% endif %}
                    {% if row == 7 and col % 2 == 0 %}
                        {% set sheep_index = col // 2 %}
                        <!-- Pionki owiec tylko co drugą komórkę w ostatnim rzędzie -->
                        <div class="piece sheep" id="sheep{{ sheep_index }}" data-piece-type="sheep" style="cursor: pointer;"
                            data-initial-row="{{ initialSheepPositions[sheep_index][0] }}" data-initial-col="{{ initialSheepPositions[sheep_index][1] }}"
                            data-current-row="{{ initialSheepPositions[sheep_index][0] }}" data-current-col="{{ initialSheepPositions[sheep_index][1] }}"
                            onstop="handlePieceStop(event, ui, 'sheep{{ sheep_index }}')">
                        </div>
                    {% endif %}
                </div>
            {% endfor %}
        {% endfor %}
    </div>

        <form id="gameForm" action="/game" method="POST">
            <input type="hidden" id="moveData" name="move" value="">
        </form>



    {% endblock content %}

    <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>


    <script>

        var currentPlayerRole = "{{ session.get('player_role') }}";
        console.log('Current Player Role:', currentPlayerRole);

        async function executeMove(pieceId, currentPosition) {
            console.log('Executing move for pieceId:', pieceId, 'at position:', currentPosition);

            var userMove = {
                pieceId: pieceId,
                position: currentPosition
            };

            try {
                const response = await fetch('/game', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ move: userMove }),
                    credentials: 'same-origin',
                });

                // Sprawdź, czy odpowiedź zawiera błąd
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                // Tutaj można dodać dodatkową logikę w przypadku udanej odpowiedzi

            } catch (error) {
                console.error('Error during fetch:', error);
            }
        }





         function isDiagonalMovement(startPosition, endPosition) {
            const dx = Math.abs(endPosition.left - startPosition.left);
            const dy = Math.abs(endPosition.top - startPosition.top);
            return dx === dy;
         }


         function handlePieceDrag(event, ui, movePieceFunction) {
            const startPosition = ui.originalPosition;
            const endPosition = ui.helper.position();

            // Sprawdzenie, czy ruch jest na ukos
            if (isDiagonalMovement(startPosition, endPosition)) {
                // Dodaj logikę przemieszczania pionka
                movePieceFunction({
                    row: Math.floor(endPosition.top / 50),
                    col: Math.floor(endPosition.left / 50)
                });
            } else {
                // Jeśli ruch nie jest na ukos, przywróć poprzednią pozycję
                ui.helper.css(ui.originalPosition);
            }
        }

        function handlePieceStop(event, ui, pieceId) {
            const currentPosition = {
                row: Math.floor(ui.position.top / 50),
                col: Math.floor(ui.position.left / 50)
            };
            // Dodaj sprawdzenie, czy ruch już został zgłoszony
            if (!ui.helper.data("moveReported")) {
                ui.helper.data("moveReported", true); // Oznacz ruch jako zgłoszony

                // Przed uruchomieniem funkcji executeMove sprawdź, czy ruch już został zgłoszony
                executeMove(pieceId, currentPosition);
            }

        }

        function handlePieceDrop(event, ui, pieceId) {
            const currentPosition = {
                row: Math.floor(ui.position.top / 50),
                col: Math.floor(ui.position.left / 50)
            };

            executeMove(pieceId, currentPosition);
        }


        function setDraggableProperties() {
            var pieceId = "";

            $(".piece").on("stop", function(event, ui) {
                // Zmienna pieceId jest dostępna tutaj
                pieceId = $(this).attr("id");

                // Upewnij się, że pieceId nie jest undefined przed wywołaniem startsWith
                if (pieceId) {
                    if (currentPlayerRole === "wilk" && pieceId === "wolf") {
                        // Wykonaj kod tylko dla wilka
                        executeMove(pieceId, {
                            row: Math.floor(ui.position.top / 50),
                            col: Math.floor(ui.position.left / 50)
                        });
                    } else if (currentPlayerRole === "owca" && pieceId.startsWith("sheep")) {
                        // Wykonaj kod tylko dla owiec
                        executeMove(pieceId, {
                            row: Math.floor(ui.position.top / 50),
                            col: Math.floor(ui.position.left / 50)
                        });
                    }
                }
            });


            if (currentPlayerRole === "wilk") {
                pieceId = "wolf";
                $("#wolf").draggable({
                    containment: ".board",
                    grid: [50, 50],
                    disabled: false,
                    drag: function (event, ui) {
                      const startPosition = ui.originalPosition;
                      const endPosition = ui.position;

                      // Sprawdzenie, czy ruch jest na ukos
                      if (!isDiagonalMovement(startPosition, endPosition)) {
                          // Jeśli nie, przywróć poprzednią pozycję
                          $(this).draggable('option', 'revert', true);
                      } else {
                          // W przeciwnym razie, usuń opcję revert
                          $(this).draggable('option', 'revert', false);
                      }
                  },
                  stop: function (event, ui) {
                    pieceId = $(this).attr("id");
                    handlePieceStop(event, ui, pieceId);
                },
                drop: function (event, ui) {
                    const pieceId = $(this).attr("id");
                    handlePieceDrop(event, ui, pieceId);
                }
                });
            } else if (currentPlayerRole === "owca") {
                pieceId = "sheep";
                $(".sheep").draggable({
                    containment: ".board",
                    grid: [50, 50],
                    disabled: false,
                    drag: function (event, ui) {
                      const startPosition = ui.originalPosition;
                      const endPosition = ui.position;

                      // Sprawdzenie, czy ruch jest na ukos
                      if (!isDiagonalMovement(startPosition, endPosition)) {
                          // Jeśli nie, przywróć poprzednią pozycję
                          $(this).draggable('option', 'revert', true);
                      } else {
                          // Sprawdzenie, czy pionek nie cofa się do poprzedniego rzędu
                          const startRow = Math.floor(startPosition.top / 50);
                          const endRow = Math.floor(endPosition.top / 50);
                          if (endRow > startRow) {
                              // Jeśli pionek cofa się do poprzedniego rzędu, przywróć poprzednią pozycję
                              $(this).draggable('option', 'revert', true);
                          } else {
                              // W przeciwnym razie, usuń opcję revert
                              $(this).draggable('option', 'revert', false);
                          }
                      }

                    },
                    stop: function (event, ui) {
                        pieceId = $(this).attr("id");
                        handlePieceStop(event, ui, pieceId);
                     },
                    drop: function (event, ui) {
                        const pieceId = $(this).attr("id");
                        handlePieceDrop(event, ui, pieceId);
                    }
                });
            }
        }

        function moveWolfPiece(currentPosition) {
            const wolfPiece = $("#wolf");
            wolfPiece.data("current-row", currentPosition.row);
            wolfPiece.data("current-col", currentPosition.col);
            updatePieceView(wolfPiece, currentPosition);
        }


        function moveSheepPiece(currentPosition) {
            const sheepPiece = $(".sheep.ui-draggable-dragging");
            const pieceId = sheepPiece.attr("id");
            sheepPiece.data("current-row", currentPosition.row);
            sheepPiece.data("current-col", currentPosition.col);
            updatePieceView(sheepPiece, currentPosition);
        }

        function updatePieceView(piece, currentPosition) {
            // Zaktualizuj widok dla danego pionka
            piece.css({
                top: currentPosition.row * 50,
                left: currentPosition.col * 50
            });
        }

        $(document).ready(function() {
            setDraggableProperties();
        });

    </script>
</body>
</html>
